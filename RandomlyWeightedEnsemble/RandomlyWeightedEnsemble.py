import keras
from keras.datasets import cifar10
from keras.preprocessing.image import ImageDataGenerator

from cleverhans.utils_mnist import data_mnist
from cleverhans.model import Model, CallableModelWrapper
from cleverhans.attacks import FastGradientMethod, CarliniWagnerL2
import cleverhans.utils_tf as utils_tf

import numpy as np
import tensorflow as tf
import keras.backend as K
import matplotlib.pyplot as plt
import os
from pathlib import Path

import models
import detectors
import utils

#Inizializzare il classifier
#Training rilevatori
#Interfaccia unica rilevatori
#Implementare RWE
#Implementare bilanciamento
#Test: Curva ROC rilevatori
#Test: RWE > Ensemble Statica, RWE > Attacchi singoli
#Plottare Distorsione vs AUC ROC

#Problema: Le reti keras rompono il gradiente

#Il PCA Whitening può avere un suo utilizzo nel bilanciamento?
#Tra l'altro il bilanciamento si chiama "decorrelazione" (credo)

#Metodo facile(?) da implementare: usare la top probability come confidence

#Tenere anche conto di quanto gli attacchi distorgono


#Per retrainer e simili: usare la differenza di previsione tra vittima e rilevatore


class ClassifierWithDetector(Model):
    def __init__(self, classifier, detector, hide_classifier=False, hide_detector=False):
        self.classifier = classifier
        self.detector = detector
        self.hide_classifier = hide_classifier
        self.hide_detector = hide_detector

    def fprop(self, x):
        y = self.classifier.classify()
        confidence = self.detector.detect(self.classifier, x, y)

        #è il modo corretto di nascondere?
        if self.hide_classifier:
            y = tf.stop_gradient(y)

        if self.hide_detector:
            confidence = tf.stop_gradient(confidence)

        
        
        #Come gestire la loss per quando il rilevatore identifica l'adversarial?
        #E in particolare, come combinare i due?

        return super().fprop(x)

def train(model, x_train, y_train,  save_dir, model_name, optimizer=keras.optimizers.rmsprop(lr=0.0001, decay=1e-6), num_classes = 10, batch_size = 32, epochs = 100):
    model.compile(loss='categorical_crossentropy',
              optimizer=optimizer,
              metrics=['accuracy'])

    x_train = x_train.astype('float32')
    x_train /= 255

    # Convert class vectors to binary class matrices.
    y_train = keras.utils.to_categorical(y_train, num_classes)

    print('Using real-time data augmentation.')
    # This will do preprocessing and realtime data augmentation:
    datagen = ImageDataGenerator(
        featurewise_center=True,  # set input mean to 0 over the dataset
        samplewise_center=False,  # set each sample mean to 0
        featurewise_std_normalization=True,  # divide inputs by std of the dataset
        samplewise_std_normalization=False,  # divide each input by its std
        zca_whitening=False,  # apply ZCA whitening
        rotation_range=0,  # randomly rotate images in the range (degrees, 0 to 180)
        width_shift_range=0.1,  # randomly shift images horizontally (fraction of total width)
        height_shift_range=0.1,  # randomly shift images vertically (fraction of total height)
        horizontal_flip=True,  # randomly flip images
        vertical_flip=False)  # randomly flip images

    # Compute quantities required for feature-wise normalization
    # (std, mean, and principal components if ZCA whitening is applied).
    datagen.fit(x_train)

    # Fit the model on the batches generated by datagen.flow().
    model.fit_generator(datagen.flow(x_train, y_train,
                                    batch_size=batch_size),
                        epochs=epochs,
                        workers=4)

    # Save model and weights
    if not os.path.isdir(save_dir):
        os.makedirs(save_dir)
    model_path = os.path.join(save_dir, model_name)
    model.save(model_path)

def main_tf():
    (x_train, y_train), (x_test, y_test) = cifar10.load_data()

    directory = './saved_models'
    filename = 'keras_cifar10_trained_model.h5'
    path = os.path.join(directory, filename)

    sess = tf.Session()

    with sess.as_default():
        x_train = x_train.astype('float32')
        x_test = x_test.astype('float32')
        x_train /= 255
        x_test /= 255
        y_train = keras.utils.to_categorical(y_train, num_classes)
        y_test = keras.utils.to_categorical(y_test, num_classes)

        print('Checking if saved model exists')
        if Path(path).exists():
            print('Found!')
            model = keras.models.load_model(path)
        else:
            print('Model not found. Training from scratch...')
            x_placeholder = tf.placeholder(dtype=tf.float32, shape=(None, 32, 32, 3))
            y_placeholder = tf.placeholder(tf.float32, shape=(None, 10))
            y = models.cifar10_tf(x_placeholder)

            args = {
                'nb_epochs' : 50,
                'learning_rate' : 0.001,
                'batch_size' : 128,
                'train_dir' : directory,
                'filename' : filename
                }

            utils_tf.model_train(sess, x_placeholder, y_placeholder, y, x_train, y_train, save=True, args=args)

        num_classes = 10

        



        datagen = ImageDataGenerator(featurewise_center=True, featurewise_std_normalization=True)
        datagen.fit(x_train)
    
        iterator = datagen.flow(x_train, y_train, batch_size=100, shuffle=False)

        model_wrapper = KerasModelWrapper(model)
        attack = FastGradientMethod(model_wrapper)
        detector = detectors.MaxProbability()

        false_positive_rates, true_positive_rates, area_under_curve = utils.test_detector(iterator, model, attack, detector)
    
        plt.figure()
        lw = 2
        plt.plot(false_positive_rate, true_positive_rate, color='darkorange', lw=lw, label='ROC curve (area = {:.2f}%)'.format(area_under_curve * 100.0))
        plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')
        plt.xlim([0.0, 1.0])
        plt.ylim([0.0, 1.0])
        plt.xlabel('False Positive Rate')
        plt.ylabel('True Positive Rate')
        plt.title('Receiver Operating Characteristic')
        plt.legend(loc='lower right')
        plt.show()

def main_keras():
    (x_train, y_train), (x_test, y_test) = cifar10.load_data()

    directory = './saved_models'
    filename = 'keras_cifar10_trained_model.h5'
    path = os.path.join(directory, filename)

    print('Checking if saved model exists')
    if Path(path).exists():
        print('Found!')
        model = keras.models.load_model(path)
    else:
        print('Model not found. Training from scratch...')
        model = models.cifar10_cnn([32, 32, 3], 10)
        train(model, x_train, y_train, directory, filename, 
              optimizer=keras.optimizers.rmsprop(lr=0.0001, decay=1e-6),
              batch_size=32,
              epochs=100)
        print('Done!')

    output = model.predict(x_train[0:1000])
    input_op, output_op = utils.keras_to_tensorflow(model)
    with K.get_session().graph.as_default():
        output2 = K.get_session().run(output_op, {input_op : x_train[0:1000]})
    #print(np.argmax(output, axis=1) == np.argmax(output2, axis=1))
    #print(np.where(np.sum(output - output2, axis=1) > 1e-9))
    print(np.sum(output - output2, axis=1)[np.sum(output - output2, axis=1) > 1e-9])
    num_classes = 10

    x_train = x_train.astype('float32')
    x_test = x_test.astype('float32')
    x_train /= 255
    x_test /= 255
    y_train = keras.utils.to_categorical(y_train, num_classes)
    y_test = keras.utils.to_categorical(y_test, num_classes)



    datagen = ImageDataGenerator(featurewise_center=True, featurewise_std_normalization=True)
    datagen.fit(x_train)
    
    iterator = datagen.flow(x_train, y_train, batch_size=100, shuffle=False)

    model_wrapper = KerasModelWrapper(model)
    attack = FastGradientMethod(model_wrapper)
    detector = detectors.MaxProbability()

    false_positive_rates, true_positive_rates, area_under_curve = utils.test_detector(iterator, model, attack, detector)
    
    plt.figure()
    lw = 2
    plt.plot(false_positive_rate, true_positive_rate, color='darkorange', lw=lw, label='ROC curve (area = {:.2f}%)'.format(area_under_curve * 100.0))
    plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.0])
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic')
    plt.legend(loc='lower right')
    plt.show()

def main():
    main_tf()

if __name__ == '__main__':
    main()
